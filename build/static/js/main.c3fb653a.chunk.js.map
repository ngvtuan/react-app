{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["App","useState","videoSrc","setVideoSrc","setImg","message","setMessage","ffmpeg","createFFmpeg","log","corePath","doTranscode","a","document","querySelectorAll","frameSpeed","images","length","load","i","fetchFile","FS","run","data","URL","createObjectURL","Blob","buffer","type","urlSearchParams","URLSearchParams","window","location","search","params","Object","fromEntries","entries","qrcode","val","str","chunkQuantity","numChunks","Math","ceil","chunks","Array","o","substr","splitStringIntoChunks","className","src","controls","style","width","height","href","target","rel","onClick","map","qr","idx","value","renderAs","marginBottom","marginRight","Boolean","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console"],"mappings":"iRA0EeA,MApEf,WAAgB,IAAD,EACb,EAAgCC,mBAAS,IAAzC,mBAAOC,EAAP,KAAiBC,EAAjB,KACA,EAAsBF,mBAAS,IAA/B,mBAAYG,GAAZ,WACA,EAA8BH,mBAAS,4BAAvC,mBAAOI,EAAP,KAAgBC,EAAhB,KACMC,EAASC,uBAAa,CAC1BC,KAAK,EACLC,SAAU,8DAeNC,EAAW,uCAAG,oCAAAC,EAAA,6DACLC,SAASC,iBAAiB,WAMjCC,EAA6B,IAL7BC,EAAS,CAAC,IAAK,IAAK,IAAK,MAKLC,OAE1Bb,EAAOY,EAAO,IATI,SAUZT,EAAOW,OAVK,OAWlBZ,EAAW,0BACXA,EAAW,qBAEFa,EAAI,EAdK,YAcFA,EAAIH,EAAOC,QAdT,6BAehBV,EAfgB,oBAeeY,EAff,kBAe8BC,oBAAU,wBAAD,OAAyBD,EAAzB,SAfvC,yBAeTE,GAfS,UAeN,YAfM,mBAciBF,GAAK,EAdtB,wCAkBZZ,EAAOe,IAAI,aAAc,KAAM,gBAAiB,OAAQ,KAAM,QAAS,MAAvE,iBAAwFP,EAAxF,QAA0G,OAAQ,OAAQ,YAAa,OAAQ,UAAW,WAAY,UAAW,WAlBrK,QAqBlB,IAFAT,EAAW,wBACLiB,EAAOhB,EAAOc,GAAG,WAAY,WAC1BF,EAAI,EAAGA,EAAIH,EAAOC,OAAQE,GAAK,EACtCZ,EAAOc,GAAG,SAAV,eAA4BF,EAA5B,SAEFhB,EAAYqB,IAAIC,gBAAgB,IAAIC,KAAK,CAACH,EAAKI,QAAS,CAAEC,KAAM,gBAxB9C,4CAAH,qDA0BXC,EAAkB,IAAIC,gBAAgBC,OAAOC,SAASC,QACtDC,EAASC,OAAOC,YAAYP,EAAgBQ,WAE9CC,EAAS,GAKb,OAJA,OAAIJ,QAAJ,IAAIA,OAAJ,EAAIA,EAAQK,OACVD,EA3C4B,SAACE,EAAKC,GAIlC,IAHA,IAAMC,EAAYC,KAAKC,KAAKJ,EAAIvB,OAASwB,GACnCI,EAAS,IAAIC,MAAMJ,GAEhBvB,EAAI,EAAG4B,EAAI,EAAG5B,EAAIuB,IAAavB,EAAG4B,GAAKN,EAC9CI,EAAO1B,GAAKqB,EAAIQ,OAAOD,EAAGN,GAG5B,OAAOI,EAmCEI,CAAsBf,EAAOK,IAAK,MAI3C,sBAAKW,UAAU,MAAf,UACE,sBACChD,EAAW,qCAAE,uBAAOiD,IAAKjD,EAAUkD,UAAQ,EAACC,MAAO,CAAEC,MAAO,QAASC,OAAQ,WAAmB,uBAAK,mBAAGC,KAAMtD,EAAUuD,OAAO,SAASC,IAAI,sBAAvC,sBAAyE,0BAAW,KAC1L,wBAAQC,QAAShD,EAAjB,mBACA,4BAAIN,IAJN,UAKGiC,SALH,aAKG,EAAQsB,KAAI,SAACC,EAAIC,GAAL,OACX,cAAC,IAAD,CAAQC,MAAOF,EAAcG,SAAS,MAAMd,UAAU,SAASG,MAAO,CAAEY,aAAc,OAAOC,YAAa,OAAQZ,MAAO,MAAOC,OAAQ,QAAhHO,UCxDZK,QACW,cAA7BpC,OAAOC,SAASoC,UAEe,UAA7BrC,OAAOC,SAASoC,UAEhBrC,OAAOC,SAASoC,SAASC,MACvB,2DCZNC,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEF3D,SAAS4D,eAAe,SDyHpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLC,QAAQD,MAAMA,EAAM5E,c","file":"static/js/main.c3fb653a.chunk.js","sourcesContent":["import React, { useState } from 'react';\nimport { createFFmpeg, fetchFile } from '@ffmpeg/ffmpeg';\nimport QRCode from 'qrcode.react';\n\nimport './App.css';\n\nfunction App() {\n  const [videoSrc, setVideoSrc] = useState('');\n  const [img, setImg] = useState('');\n  const [message, setMessage] = useState('Click Start to transcode');\n  const ffmpeg = createFFmpeg({\n    log: true,\n    corePath: 'https://unpkg.com/@ffmpeg/core@0.10.0/dist/ffmpeg-core.js'\n  });\n\n  const splitStringIntoChunks = (str, chunkQuantity) => {\n    const numChunks = Math.ceil(str.length / chunkQuantity)\n    const chunks = new Array(numChunks)\n\n    for (let i = 0, o = 0; i < numChunks; ++i, o += chunkQuantity) {\n      chunks[i] = str.substr(o, chunkQuantity)\n    }\n\n    return chunks\n  }\n\n\n  const doTranscode = async () => {\n    const svgs = document.querySelectorAll('.qrcode')\n    const images = [\"a\", \"b\", \"c\", \"d\"]\n    // for (let i = 0; i < svgs.length; i++) {\n    //   const str = new XMLSerializer().serializeToString(svgs[i])\n    //   images.push(window.btoa(str))\n    // }\n    const frameSpeed = images.length * 32;\n\n    setImg(images[0])\n    await ffmpeg.load();\n    setMessage('Loading ffmpeg-core.js');\n    setMessage('Start transcoding');\n\n    for (let i = 0; i < images.length; i += 1) {\n      ffmpeg.FS('writeFile', `img00${i}.png`, await fetchFile(`./assets/qrcode/img00${i}.png`));\n    }\n\n    await ffmpeg.run('-framerate', '60', '-pattern_type', 'glob', '-i', '*.png', '-vf', `setpts=${frameSpeed}*PTS`, '-c:a', 'copy', '-shortest', '-c:v', 'libx264', '-pix_fmt', 'yuv420p', 'out.mp4');\n    setMessage('Complete transcoding');\n    const data = ffmpeg.FS('readFile', 'out.mp4');\n    for (let i = 0; i < images.length; i += 1) {\n      ffmpeg.FS('unlink', `img00${i}.png`);;\n    }\n    setVideoSrc(URL.createObjectURL(new Blob([data.buffer], { type: 'video/mp4' })));\n  };\n  const urlSearchParams = new URLSearchParams(window.location.search);\n  const params = Object.fromEntries(urlSearchParams.entries());\n\n  let qrcode = []\n  if (params?.val) {\n    qrcode = splitStringIntoChunks(params.val, 300)\n  }\n\n  return (\n    <div className=\"App\">\n      <p/>\n      {videoSrc ? <><video src={videoSrc} controls style={{ width: '150px', height: \"150px\" }}></video><br/><a href={videoSrc} target=\"_blank\" rel=\"noopener noreferrer\">Download</a><br/></> : null}\n      <button onClick={doTranscode}>Start</button>\n      <p>{message}</p>\n      {qrcode?.map((qr, idx) => (\n        <QRCode value={qr} key={idx} renderAs=\"svg\" className=\"qrcode\" style={{ marginBottom: '20px',marginRight: '20px', width: '1px', height: '1px' }} />\n      ))}\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}